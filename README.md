# Chisellize C910 gpfb
按复旦大学嵌入式H的要求，自学了chisel并学习了C910数据预取的gpfb模块，其含有gpfb,l1sm,l2sm,tsm以及gated_clk模块

对其verilog源码实现了chisel化，并成功发射成为verilog代码，**目前还没有**进行测试
## chisel化过程中一些学习
1. 时钟域：可以使用一个withClockAndReset块内声明所有和单个时钟相关的寄存器，接收块返回值。之后该寄存器和外部时序逻辑混用
2. 对于chisel不支持部分位赋值的问题：chisel支持位选读的写法，但不支持位选写的写法。我觉得其实没有问题，verilog使用位选写的语法，如果是wire类型，那么没有提及的
位其实被认为是高阻态了。我们可以在chisel中直接实现在端口定义的时候就参数化，位选的宽度直接声明端口的时候就做好。（但其实我在chisel过程中没有这么做，而是对于没有提及的位用了补0的手段，实现方法是用的 ## 拼接）
3. 模块名：使用了override def desiredName: String = s"ct_lsu_pfu_pfb_l${chose+1}sm"，用到了scala的字符串插值语法，实现了例化两个l1sm的时候，根据参数生成不同模块名的实例
4. **参数化生成不同的模块**：个人认为在实现chisel过程中最能展现chisel强大的一处！根据对l1sm和l2sm的分析，两者的逻辑有大量的重合，仅仅在部分端口名字和信号连接上面有不同。针对这种情况，两种解决方法
   1. 先写一个基础模板，将所有相同的逻辑写上去，然后l1sm和l2sm都继承基础模板，再重写相关的端口名字和部分不同的逻辑
   2. 写一个综合模板，根据输入的参数不同生成不同的模块，**我就是用这种方法**。首先写了一个l1sm的综合模块，根据传入的参数chose来决定生成什么样的模块
5. 可有可无的端口问题：一般出现在参数化生成模块的情景中。综合模板为了根据参数生成不同模块，需要对端口和逻辑进行可选化设计。使用scala的some语法，使用到该端口时候要用get获取。（网上说也可以用0位宽，但是0位宽是
生成verilog可以对一些0位宽端口优化，但是chisel的连接逻辑会有问题）
6. 快速模块例化与端口连接：
   1. 对于相同的模块例化，直接VecInit(Seq.fill(...))来例化多个相同模块，然后相同模块直接<>快速连接。
   2. 对于不同的模块例化，如果模块逻辑和结构比较相近。
      1. 对于相同功能的端口用一个Bundle，然后<>连接这部分端口。对于结构和逻辑不同端口再手动连接(也可以所有的端口都在一个Bundle,但是几个相同的端口用List或者Bundle再包一层)
      2. 几个模块一起打包为List，用for对相似逻辑一起连接，if对不同端口不同操作
7. scala和chisel结合体验：控制结构 -> 集合 + 函数编程 -> 面向对象，虚对象虚方法等




## TODO：优化想法
1. 可以将assign等赋值语句用list.map实现，如将相似的与门assign左侧装到一个list，右侧装到一个list，再对左侧list.map
2. 在对state参数进行定义时，使用了chiselEnum的语法，但是和reg一起使用会有很多奇怪报错，主要在于类型问题，chisel中这方面经过调试可以跑，但类型匹配还没懂，建议可以用List等